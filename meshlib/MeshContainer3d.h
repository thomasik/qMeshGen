/////////////////////////////////////////////////////////////////////////////
// MeshContainer3d.h
/////////////////////////////////////////////////////////////////////////////
//	Tomasz Jurczyk,	2002-
//	Generation of unstructured meshes
/////////////////////////////////////////////////////////////////////////////

#pragma once

#if !defined(MESHCONTAINER3D_H__INCLUDED)
#define MESHCONTAINER3D_H__INCLUDED

#include <memory>

class MeshContainer2d;
class OctTree;
class MeshTetrahedron;
class MeshBoundaryCondition;

#include "DataContainer.h"
#include "DRect.h"
#include "DataVector.h"
#include "MeshPoint3d.h"
#include "MeshBlock.h"
#include "IteratorMesh2d.h"
#include "IteratorMesh3d.h"
#include "IteratorEdge3d.h"
#include "IteratorFace.h"
#include "MeshData.h"
#include "ControlSpace3dAdaptive.h"
#include "DataStatistics.h"
#include "ControlSpace3d.h"
#include "MeshDomainVolume.h"
#include "MeshViewSet.h"

#include "SurfaceParametric.h"
#include "Curve3dParametric.h"

/**
 * This class implements a container of mesh points and blocks for 3D discretization.
 */
class MeshContainer3d 
{
public:
	/// Standard constructor
	MeshContainer3d(int part_size, 
		MeshContainer3d* total_volume_mesh = nullptr, 
		MeshContainer3dSurface* total_surface_mesh = nullptr);
	/// Standard destructor
	virtual ~MeshContainer3d();
public:
	struct AdditionalBoundaryNode{
		MeshPoint3d* point;
		DataVector<MeshPoint3d*> other_points;
		AdditionalBoundaryNode(MeshPoint3d* additional_point = nullptr, int other_count = 4)
			: point(additional_point), other_points(other_count) {}
	};
public:
	/// mark boundary edges for boundary faces with sharp angle
	void markSharpBoundaryEdges(double fmax = 0.2);
	/// update boundary flags for outer faces/edges/nodes
	void markOuterBoundary();
	/// show quality statistics
	void logQuality(bool with_openmp = true) const;
	///// Partition mesh (remove marked blocks and transfer them to other mesh)
	//MeshContainer3d* splitByBlocks(int area_id);
	/// Store mesh (clipped) in matlab .m format
	bool storeMatlabFile(const string& fname, const DPoint3d& clip, double quality_clip) const;
	/// Remove all tags
	void removeAllTags();
	/// Remove all tags of the given type
	void removeAllTags(TagExtended::TagType tag_type);
	/// Returns the iterator for browsing all faces in this mesh
	IteratorFace getFirstFace() const { return IteratorFace(this); }
	/// Returns the iterator for browsing all edges in this mesh
	IteratorEdge3d getFirstEdge3d(TagExtended::TagType tag_type = TagExtended::TAG_NONE, int tag_value = 1) const { 
		return IteratorEdge3d(this, tag_type, tag_value); }
	DataVector<MeshEdge3d*> getEdges3d(TagExtended::TagType tag_type = TagExtended::TAG_NONE, int tag_value = 1);
	DataVector<const MeshEdge3d*> getEdges3d(TagExtended::TagType tag_type = TagExtended::TAG_NONE, int tag_value = 1) const;
	/// Returns statistical information about minimum inner angles (dihedral)
	bool statMinDihedralAngles(DataStatistics& stats) const;
	/// Returns statistical information about number of blocks adjacent to each edge
	bool statEdgeBlockAdjacency(DataStatistics& stats, bool inner_only) const;
	/// Returns statistical information about number of blocks adjacent to each vertex
	bool statVertexBlockAdjacency(DataStatistics& stats, bool inner_only) const;
	/// Returns statistical information about difference betweent the current metric and metric generated by element
	bool statMetricDifference(Metric3dContext& mc, DataStatistics& stats) const;
	/// Returns statistical information about difference betweent the current metric and metric generated by element
	bool statMetricDifferenceNoOMP(Metric3dContext& mc, DataStatistics& stats) const;
	/// Returns statistical information about "mean ratio" shape quality in metric
	bool statMeanRatio(Metric3dContext& mc, DataStatistics& stats, bool ext_metric) const;
	/// Returns statistical information about lengths of mesh edges in the current metric
	bool statMetricEdgeLength(Metric3dContext& mc, DataStatistics& stats, bool ext_metric) const;
	/// Returns statistical information about lengths of mesh edges in the current metric
	bool statMetricEdgeLengthNoOMP(Metric3dContext& mc, DataStatistics& stats, bool ext_metric) const;
	/// Prints controlspace related quality of mesh
	int logMetricQuality2d();
	/// Returns number of faces with the given number of edges
	int getFaceCount(int ect) const;
	/// Stores 3d mesh into text file
	bool storeTetmesh(const string& fname, int id = -1) const;
	/// Stores 3d mesh into text file
	bool storeFacesOFF(const string& fname, int id = -1) const;
	/// Stores 3d mesh into text file
	bool storeTxt(const string& fname, int id = 0) const;
	/// Stores 3d mesh into text file for PJM
	bool storePJM(const string& fname, int grid_type, int id = 0) const;
	/// Returns length distribution of metric edges
	int getMetricEdgeRange(Metric3dContext& mc, int ranges_count, double ranges[], int stats[]);
	/// Returns quality distribution of tetrahedral blocks
	int getTetrahedraQualityRange(Metric3dContext& mc, int ranges_count, double ranges[], int stats[], 
		MeshData::StatData stat_data[], int count_data[]);
	/// Returns quality stats of tetrahedral blocks
	MeshData::StatData getTetrahedraQualityStats(Metric3dContext& mc) const;
	/// Returns the "screenshot" of mesh as compared to boundary for visualization during debug
	MeshViewSet* getDebugViewSet(const MeshContainer3d* boundary) const;
	/// Returns the "screenshot" of subarea of this mesh for visualization during debug
	MeshViewSet* getDebugViewSet(const MeshBlock* el1, const MeshBlock* el2 = nullptr, double radius = 2.0) const;
	/// Returns the "screenshot" of subarea of this mesh for visualization during debug
	MeshViewSet* getDebugViewSet(const MeshPoint3d* pt1, const MeshPoint3d* pt2 = nullptr, double radius = 2.0) const;
	/// Returns the "screenshot" of this mesh for visualization
	MeshViewSet* getBoundaryEdgesViewSet(MeshViewSet* set = nullptr) const;
	/// Returns the "screenshot" of this mesh for visualization
	MeshViewSet* getViewSet(MeshViewSet* set = nullptr, int part_id = -2) const;
	/// Returns the "screenshot" of this mesh for visualization
	MeshViewSet* getViewSetWithVisibleBlocksOnly(const DataVector<MeshViewSet::ClipPlane> * clip_planes = nullptr,
		MeshViewSet* set = nullptr, int part_id = -2) const;
	/// Returns the "screenshot" of this mesh for visualization
	MeshViewSet* getViewSetWithVisibleFacesOnly(const DataVector<MeshViewSet::ClipPlane> * clip_planes = nullptr,
		MeshViewSet* set = nullptr, int id = -2, int show_part_id = -2) const;
	/// Checks consistency of this mesh
	bool isValid() const;
	/// Returns first 2d boundary (mainly for 2d meshing, when there is only one face)
	MeshContainer2d* getFirst2dBoundary();
	/// Returns the iterator for browsing all 2d-meshes
	IteratorMesh2d getFirstValidMesh2d() { return IteratorMesh2d(this); }
	DataVector<MeshContainer2d*> getValidMeshes2d();
	/// Returns the iterator for browsing all 2d-boundary domains
	IteratorBoundary2d getFirstValidBoundary2d() { return IteratorBoundary2d(this); }
	DataVector<MeshDomainSurface*> getValidBoundaries2d();
	/// Returns the iterator for browsing all 3d-meshes
	IteratorMesh3d getFirstValidMesh3d() { return IteratorMesh3d(this); }
	/// Inserts the given number of inner nodes for each mesh edge in this container
//	void addEdgeInnerPoints(int count, bool use_shapes = true);
	/// Switches the position of two mesh points in the container (their indices)
	void switchMeshPoints(int i, int j){ m_points->switchDataItems(i, j); }
	/// Clears all discretization data for all domain-blocks within this container
	void clearDiscretization();
	/// Clears discretization of blocks for all domain-blocks within this container
	void clearDiscretization3d();
	/// Clears discretization of faces for all domain-blocks within this container
	void clearDiscretization2d();
	/// Clears discretization of edges for all domain-blocks within this container
	void clearDiscretization1d();
	/// Clears all CS data for all domain-blocks within this container
	void clearCS();
	/// Clears CS of blocks for all domain-blocks within this container
	void clearCS3d();
	/// Clears CS of faces for all domain-blocks within this container
	void clearCS2d();
	/// Removes all points and blocks (references AND objects)
	void deleteAll();
	/// Returns the number of mesh points in the container
	int getPointsCount() const { return m_points->countInt(); }
	/// Returns the number of mesh blocks (3D mesh elements) in the container
	int getBlocksCount() const { return m_blocks->countInt(); }
	/// Returns the number of mesh blocks (3D mesh elements) with the given number of faces
	int getBlocksCountForFaces(int face_count) const;
	/// Returns the point (a pointer to it) at the given index within the container
	MeshPoint3d* getPointAt(int index) const { return m_points->getDataAt(index); }
	/// Returns the block (a pointer to it) at the given index within the container
	MeshBlock* getBlockAt(int index) const { return m_blocks->getDataAt(index); }
	/// Deletes all mesh points (both references and objects) from this container
	void deleteAllMeshPoints(){ m_points->deleteAll(); }
	/// Deletes all mesh blocks (both references and objects) from this container
	void deleteAllMeshBlocks(){ m_blocks->deleteAll(); }
	/// Removes the reference to the point at the given index from the container
	MeshPoint3d* removeMeshPoint(int index){ return m_points->removeDataItem(index); }
	/// Removes the reference to the point at the given index from the container
	MeshPoint3d* removeMeshPoint(MeshPoint3d* point){ return m_points->removeDataItem(point->getIndex()); }
	/// Removes the reference to the block at the given index from the container
	MeshBlock* removeMeshBlock(int index){ return m_blocks->removeDataItem(index); }
	/// Removes the reference to the given block from the container
	MeshBlock* removeMeshBlock(MeshBlock* block){ return removeMeshBlock(block->getIndex()); }
	/// Adds the new reference to point into this container (no checks for duplicates)
	int addMeshPoint(MeshPoint3d *point){ return m_points->addDataItem(point); }
	/// Adds the new reference to block into this container (no checks for duplicates)
	int addMeshBlock(MeshBlock *block){ return m_blocks->addDataItem(block); }
	/// Adds the new reference to tetrahedron into this container (with update of search tree)
	int addMeshTetrahedron(MeshTetrahedron *tetrahedron);
	/// Removes the reference to the tetrahedron at the given index from the container (with update of search tree)
	MeshTetrahedron* removeMeshTetrahedron(MeshTetrahedron *tetrahedron);
	/// Returns the bounding cubicoid, containing all points and blocks from this container
	DBox getBoundingBox() const;
	/// Clears the oct tree used during triangulation (for fast searching of the containing triangle
	void clearSearchTree();
	/// Sets the new searching quad_tree
	void setSearchTree(std::shared_ptr<OctTree> tree);
	/// Returns the pointer to the searcht tree
	std::shared_ptr<OctTree> getSearchTree(){ return m_oct_tree; }
	/// Return maximum level of current search tree for containing triangles
	int getMaxSearchTreeLevel() const;
	/// Returns the most recently processed tetrahedron
	MeshTetrahedron* getLastTetrahedron() { return m_last_tetrahedron; }
	/// Returns the nearest triangle from the quad tree or the last triangle
	MeshTetrahedron* getNearTetrahedron(const DPoint3d& pt);
	/// Counts quality (for given criterion) for all blocks within the container
	void countQuality(Metric3dContext& mc, int criterion = -1);
	/// Counts metric difference quality for all elements within the container
	void countMetricDifferenceQuality();
	/// Returns the currently set reference to the control space
	CS3dPtr getControlSpace() const { return m_control; }
	/// Sets a reference to the class describing the control space for mesh elements in this container
	void setControlSpace(CS3dPtr space);
	/// Switches using the heap-ordering for elements
	void setHeapOrder(bool valid){ m_blocks->setHeapOrder(valid); }
	/// Checks whether the heap-order is being maintained
	bool isHeapOrder() const { return m_blocks->isHeapOrder(); }
	/// Updates the position of the given element within the heap-ordered container
	void updateBlockPosition(MeshBlock* block){ m_blocks->updateDataItemPosition(block); }
	/// Returns the coordinates of the inertial center point
	DPoint3d getInertialCenter() const;
	/// Sets the constraining stage
	void setConstrainingPhase(MeshData::TriangulationStage s) { m_constraining = s; }
	/// Returns the constraining stage
	MeshData::TriangulationStage getConstrainingPhase() const { return m_constraining; }
	/// Sets the discretization state
	void setDiscretizationState(int s) { m_discretization_state = s; }
	/// Returns the discretization state
	int getDiscretizationState() const { return m_discretization_state; }
	/// Additional boundary nodes
	DataVector<AdditionalBoundaryNode>& getAdditionalBoundaryNodes() { return m_inserted_boundary_points; }
	/// Set freepoints list
	void setFreePoints(std::shared_ptr<DataVector<std::shared_ptr<MeshPoint3d>>> fp_list = nullptr);
	/// Get freepoints list
	std::shared_ptr<DataVector<std::shared_ptr<MeshPoint3d>>> getFreePoints() const { return m_freepoints; }
	/// Set boundary-condition list
	void setBoundaryConditions(std::shared_ptr<DataVector<std::shared_ptr<MeshBoundaryCondition>>> mbc_list = nullptr);
	/// Gather volume meshes from all domain volumes in this model and combine them in the total_mdv
	bool gatherVolumeMeshes();
	/// Return total-discretization domain-volume
	const MeshDomainVolume* getTotalMDV() const { return &total_mdv; }
	/// Removes all local surface definitions and counters
	void clearLocalShapes();
	/// Add new local surface
	void addLocalSurface(const SurfacePtr& surface);
	/// Add new local curve
	void addLocalCurve(const Curve3dPtr& curve);
	/// Tries to move border points to fit theirs ascribed local surfaces
	int movePointsToLocalShape(Metric3dContext& mc, TagExtended::TagType tag_type = TagExtended::TAG_NONE, 
		int tag_value = 0, int forbid_tag_value = 0);
protected:
	/// Set of mesh points
	DataContainer<MeshPoint3d>	*m_points;
	/// Set of mesh blocks
	DataContainer<MeshBlock>	*m_blocks;
	/// Factor of size-increase for memory management
	int	m_part_size;
	/// Most recently processed tetrahedron (during the Delaunay tetrahedralization)
	MeshTetrahedron* m_last_tetrahedron;
	/// Oct Tree used for searching a good initial shot for tetrahedron containing the given point
	std::shared_ptr<OctTree> m_oct_tree;
	/// The reference to the control space (which governs the size and shape of created mesh-elemetns)
	CS3dPtr m_control;
	/// Constraining stage
	MeshData::TriangulationStage m_constraining;
	/// Discretization state
	int m_discretization_state;
	/// Additional boundary nodes (introduced during constraining)
	DataVector<AdditionalBoundaryNode> m_inserted_boundary_points;
	/// Free-points list
	std::shared_ptr<DataVector<std::shared_ptr<MeshPoint3d>>> m_freepoints;
	// --> boundary-condition list
	std::shared_ptr<DataVector<std::shared_ptr<MeshBoundaryCondition>>> m_mbc;
	/// additional domain-volume, for total 3d volume/surface mesh if the mesh container is for model
	MeshDomainVolume total_mdv;
	/// Container for local parameterization surfaces
	DataVector<SurfacePtr> m_local_surfaces;
	/// Container for local parameterization curves
	DataVector<Curve3dPtr> m_local_curves;
};

#endif // !defined(MESHCONTAINER3D_H__INCLUDED)
