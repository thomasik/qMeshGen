/////////////////////////////////////////////////////////////////////////////
// MeshContainer2d.h
/////////////////////////////////////////////////////////////////////////////
//	Tomasz Jurczyk,	2002-
//	Generation of unstructured meshes
/////////////////////////////////////////////////////////////////////////////

#pragma once

#if !defined(MESHCONTAINER2D_H__INCLUDED)
#define MESHCONTAINER2D_H__INCLUDED

class Curve2dParametric;
class ControlSpace3d;
class QuadTree;
class MeshTriangle2d;
class MeshViewSet;
class MeshEdge2d;
class MeshEdge3d;

#include "DataContainer.h"
#include "DRect.h"
#include "MeshPoint2d.h"
#include "MeshElement.h"
#include "MeshData.h"
#include "DataStatistics.h"
#include "IteratorEdge2d.h"
#include "Metric2dContext.h"
#include "ControlSpace2d.h"
#include "SurfaceParametric.h"

/**
 * This class implements a container of mesh points and elements for 2D (and 2.5D) discretization.
 */
class MeshContainer2d
{
public:
	/// Standard constructor
	MeshContainer2d(int part_size);
	/// Standard destructor
	virtual ~MeshContainer2d();
public:
	/// merge two meshes into one (the mesh from argument will be erased!)
	bool merge(MeshContainer2d* &mesh);
	/// converts the mesh into a boundary-mesh only (removes all inner nodes and elements)
	void convertToBoundaryMesh();
	/// Remove all tags
	void removeAllTags(TagExtended::TagType tag_type);
	/// Partition mesh (remove marked elements and transfer them to other mesh)
	MeshContainer2d* splitByElements(int area_id);
	/// Partition mesh (remove marked elements and transfer them to other mesh)
	MeshContainer2d* splitByElements(TagExtended::TagType tag_type, int tag_value);
	/// Store mesh (clipped) in matlab .m format
	bool storeMatlabFile(const string& fname, const DPoint3d& clip, double quality_clip) const;
	/// Checks whether any boundary edge has non-straight shape
	bool anyEdgeWithShape() const;
	/// Returns the iterator for browsing all edges in this mesh
	IteratorEdge2d getFirstEdge2d() const { return IteratorEdge2d(this); }
	/// Prints controlspace related quality of mesh
	int logMetricQuality(const string& caption = "");
	/// Returns the "screenshot" of subarea of this mesh for visualization during debug
	MeshViewSet* getDebugViewSet(const MeshElement* el1, const MeshElement* el2 = nullptr, double radius = 2.0) const;
	/// Returns the "screenshot" of subarea of this mesh for visualization during debug
	MeshViewSet* getDebugViewSet(const MeshPoint2d* pt1, const MeshPoint2d* pt2 = nullptr, double radius = 2.0) const;
	/// Returns the "screenshot" of this mesh for visualization
	MeshViewSet* getViewSet(MeshViewSet* set = nullptr, bool with_surface = true, 
		bool proper_orientation = true, bool with_elements = true) const;
	/// Creates an EPS-image of this mesh
	void storeEPS(const char* name = "mesh", int id = 0) const;
	/// Returns statistical information about difference betweent the current metric and metric generated by element
	bool statMetricDifference(Metric2dContext& mc, DataStatistics& stats) const;
	/// Returns statistical information about "mean ratio" shape quality in metric
	bool statMeanRatio(Metric2dContext& mc, DataStatistics& stats, bool ext_metric) const;
	/// Returns statistical information about lengths of mesh edges in the current metric
	bool statMetricEdgeLength(Metric2dContext& mc, DataStatistics& stats, bool ext_metric) const;
	/// Returns statistical information about alpha quality of elements in metric space
	bool statMetricAlphaQuality(Metric2dContext& mc, DataStatistics& stats, bool ext_metric) const;
	/// Returns statistical information about inner angles of elements
	bool statRealAngles(DataStatistics& stats) const;
	/// Returns information about the inner angles (real coordinates - no metric)
	MeshData::StatData getAngleQuality(bool on_surface = true) const;
	/// Returns information about the alpha quality (real coordinates - no metric)
	MeshData::StatData getAlphaQuality(bool on_surface = true) const;
	/// Stores 2d mesh into text file
	bool storeTxt(const string& fname, int id = 0) const;
	/// Stores surface mesh into text file
	bool storeSurf(const string& fname, bool proper_orientation, int id = 0) const;
	/// Stores 2d mesh into text file for PJM
	bool storePJM(const string& fname, int grid_type, int id = 0) const;
	/// Checks the validity of the mesh (mainly for testing purposes)
	bool isValid();
	/// Returns the minimum, maximum and average difference of node ids for mesh elements
	StatData getElementsIDSpan() const;
	/// Automatically creates control space for this 2D-patch, from already existing mesh triangles
	bool createControlSpaceFromTriangles(double factor = 1.0);
	/// Automatically creates control space for this 2D-patch, basing upon the surface and boundary curvature
	bool createControlSpace(std::shared_ptr<ControlSpace2d> user_space = nullptr,
		std::shared_ptr<ControlSpace3d> user_space_3d_1 = nullptr, 
		std::shared_ptr<ControlSpace3d> user_space_3d_2 = nullptr);
	/// Returns the number of mesh elements with the given number of edges (i.e. triangles or quads)
	int getElementsCount(int edge_count) const;
	/// Sets a reference to the class describing the control space for mesh elements in this container
	void setControlSpace(std::shared_ptr<ControlSpace2d> space);
	/// Updates the position of the given element within the heap-ordered container
	void updateElementPosition(MeshElement* element){ m_elements->updateDataItemPosition(element); }
	/// Switches the position of two mesh points in the container (their indices)
	void switchMeshPoints(int i, int j){ m_points->switchDataItems(i, j); }
	/// Removes all points and elements (references AND objects)
	void deleteAll();
	/// Enumerates all points with succesfull layers ("neighbour-ordered")
	void renumeratePointsByNeighbours(bool and_reverse = true, bool distance_sort = false);
	/// Assigns to all points their index as ID
	void renumeratePoints();
	/// Switches using the heap-ordering for elements
	void setHeapOrder(bool valid){ m_elements->setHeapOrder(valid); }
	/// Checks whether the heap-order is being maintained
	bool isHeapOrder() const { return m_elements->isHeapOrder(); }
	/// Returns the number of mesh points in the container
	int getPointsCount() const { return m_points->countInt(); }
	/// Returns the number of mesh elements in the container
	int getElementsCount() const { return m_elements->countInt(); }
	/// Returns the point (a pointer to it) at the given index within the container
	MeshPoint2d* getPointAt(int index) const { return m_points->getDataAt(index); }
	/// Returns the element (a pointer to it) at the given index within the container
	MeshElement* getElementAt(int index) const { return m_elements->getDataAt(index); }
	/// Deletes all mesh points (both references and objects) from this container
	void deleteAllMeshPoints(){ m_points->deleteAll(); }
	/// Deletes all mesh elements (both references and objects) from this container
	void deleteAllMeshElements(){ m_elements->deleteAll(); }
	/// Removes the reference to the point at the given index from the container
	MeshPoint2d* removeMeshPoint(int index){ return m_points->removeDataItem(index); }
	/// Removes the reference to the point
	MeshPoint2d* removeMeshPoint(MeshPoint2d* point){ return m_points->removeDataItem(point->getIndex()); }
	/// Removes the reference to the element at the given index from the container (additional ln(n) updates if heap-order is active)
	MeshElement* removeMeshElement(int index){ return m_elements->removeDataItem(index); }
	/// Removes the reference to the given element from the container
	MeshElement* removeMeshElement(MeshElement* element){ return removeMeshElement(element->getIndex()); }
	/// Adds the new reference to point into this container (no checks for duplicates)
	int addMeshPoint(MeshPoint2d *point){ return m_points->addDataItem(point); }
	/// Adds the new reference to element into this container (no checks for duplicates, additional ln(n) updates if heap-order is active)
	int addMeshElement(MeshElement *element){ return m_elements->addDataItem(element); }
	/// Adds the new reference to triangle into this container (with quad_tree update)
	int addMeshTriangle(MeshTriangle2d *triangle, bool no_heap = false);
	/// Removes the reference to the given triangle from the container (with quad_tree update)
	MeshTriangle2d* removeMeshTriangle(MeshTriangle2d* triangle);
	/// Returns the bounding rectangle, containing all points and elements from this container
	DRect getBoundingRect() const;
	/// Returns the currently set reference to the control space
	CS2dPtr getControlSpace() const { return m_control; }
	/// Returns the currently set reference to the parametric surface
	std::shared_ptr<const SurfaceParametric> getSurface() const { return m_surface; }
	/// Sets new reference to the parametric surface
	void setSurface(std::shared_ptr<const SurfaceParametric> surface) { m_surface = surface; }
	/// Return maximum level of current search tree for containing triangles
	int getMaxSearchTreeLevel() const;
	/// Clears the quad tree used during triangulation (for fast searching of the containing triangle)
	void clearSearchTree();
	/// Sets the new searching quad_tree
	void setSearchTree(QuadTree* tree);
	/// Returns the pointer to the searcht tree
	QuadTree* getSearchTree(){ return m_quad_tree; }
	/// Returns the most recently processed triangle
	MeshTriangle2d* getLastTriangle() { return m_last_triangle; }
	/// Returns the nearest triangle from the quad tree or the last triangle
	MeshTriangle2d* getNearTriangle(const DPoint2d& pt);
	/// Returns mesh edge connected to the given 3D edge
	MeshEdge2d* getCoupledEdge(const MeshEdge3d* edge3d) const;
	/// Counts quality (for given criterion) for all elements within the container
	void countQuality(Metric2dContext& mc, int criterion = -1);
	/// Counts metric difference quality for all elements within the container
	void countMetricDifferenceQuality();
	/// Sets the discretization state
	void setDiscretizationState(int s) { m_discretization_state = s; }
	/// Returns the discretization state
	int getDiscretizationState() const { return m_discretization_state; }
	/// Sets the constraining stage
	void setConstrainingPhase(MeshData::TriangulationStage s) { m_constraining = s; }
	/// Returns the constraining stage
	MeshData::TriangulationStage getConstrainingPhase() const { return m_constraining; }
	/// Check validity of heap
	bool validHeapOrder() const { return m_elements->validHeapOrder(); }
protected:
	/// Enumerates the IDs of points by distance from the chosen point)
	void sortByDistance(int start, int end, int target);
private:
	/// Structure for storing basic edge information
	struct EdgeInfo {
	public:
		EdgeInfo(MeshPoint2d* _pt0, MeshPoint2d* _pt1, char _btype) : pt0(_pt0), pt1(_pt1), btype(_btype) {}
	public:
		MeshPoint2d* pt0;
		MeshPoint2d* pt1;
		char btype;
	};
protected:
	/// Set of mesh points
	DataContainer<MeshPoint2d>	*m_points;
	/// Set of mesh elements
	DataContainer<MeshElement>	*m_elements;
	/// Factor of size-increase for memory management
	int	m_part_size;
	/// The reference to the control space (which governs the size and shape of created mesh-elemetns)
	CS2dPtr m_control;
	/// Most recently processed triangle (during the Delaunay triangulation)
	MeshTriangle2d* m_last_triangle;
	/// Quad Tree used for searching a good initial shot for triangle containing the given point
	QuadTree* m_quad_tree;
	/// The reference to the underlying parametric surface (if any)
	std::shared_ptr<const SurfaceParametric> m_surface;
	/// Discretization state
	int m_discretization_state;
	/// Constraining stage
	MeshData::TriangulationStage m_constraining;
};

#endif // !defined(MESHCONTAINER2D_H__INCLUDED)
